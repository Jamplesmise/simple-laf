
---
一、核心理念:熵控制驱动开发 (Entropy-Controlled Development)
🎯 根本问题
markdown
传统AI辅助开发的熵增来源:
1. 长对话上下文腐败 (信息熵增)
2. 多轮修改偏离初衷 (目标熵增)
3. 大范围改动引入Bug (结构熵增)
4. 并行开发互相污染 (协作熵增)
5. 文档与代码不同步 (知识熵增)

解决思路:
通过"入口约束"和"过程收束",
在每个环节建立熵减机制,
确保系统始终处于低熵状态。

---
二、信息架构:双层文档体系
📚 全局文档层 (Global Context Layer)
作用: 提供恒定的、统一的项目"引力场"
markdown
.ai-context/
├─ 0-project-overview.md        # 项目全貌
│  ├─ 项目身份 (名称、类型、领域)
│  ├─ 核心目标 (解决什么问题)
│  ├─ 用户画像 (服务谁)
│  ├─ 成功标准 (如何衡量成功)
│  └─ 项目边界 (不做什么)
│
├─ 1-tech-stack.md              # 技术栈锁定
│  ├─ 强制使用 (版本号精确到patch)
│  ├─ 明确禁止 (列出理由)
│  ├─ 资源配置 (CPU/内存/存储预算)
│  └─ 环境要求 (Node版本、浏览器支持)
│
├─ 2-architecture.md            # 架构设计
│  ├─ 系统拓扑图 (组件及依赖关系)
│  ├─ 数据流向 (从用户到数据库的完整路径)
│  ├─ 模块边界 (清晰的职责划分)
│  └─ 集成点 (外部系统对接方式)
│
├─ 3-interface-contracts.md     # 接口契约
│  ├─ 统一响应格式 (成功/失败/分页)
│  ├─ 错误码体系 (分类编码)
│  ├─ 认证鉴权方式 (Token格式)
│  ├─ 版本管理策略 (/api/v1, /api/v2)
│  └─ 向后兼容承诺 (Breaking Change规则)
│
├─ 4-action-standards.md        # 动作标准
│  ├─ 代码规范 (命名、格式、注释密度)
│  ├─ 提交规范 (Conventional Commits)
│  ├─ 分支策略 (Git Flow / Trunk-Based)
│  ├─ Review标准 (Checklist)
│  └─ 发布流程 (CI/CD Pipeline)
│
├─ 5-initialization-actions.md  # 初始化清单
│  ├─ 环境准备 (安装依赖、配置IDE)
│  ├─ 脚手架命令 (一键初始化)
│  ├─ 首次运行验证 (Health Check)
│  └─ 开发者账号 (权限申请流程)
│
└─ 6-resource-inventory.md      # 资源清单
   ├─ 设计资源 (Figma链接、设计系统)
   ├─ API文档 (Swagger/Apifox地址)
   ├─ 测试环境 (URL、测试账号)
   ├─ 监控面板 (Grafana、Sentry)
   └─ 知识库 (Confluence、Notion)
关键原则:
1. 恒定性: 全局文档变更需要团队评审
2. 强制性: 所有AI实例必须先读取全局文档
3. 最小化: 每个文档控制在200行以内
4. 可验证: 每条规则都有对应的Linter/Hook检查

---
📄 局部文档层 (Local Context Layer)
作用: 提供精确的、隔离的任务上下文
markdown
.ai-context/tasks/
├─ FE-001-login-page.md
│  ├─ 任务身份
│  │  ├─ ID: FE-001
│  │  ├─ 标题: 登录页面开发
│  │  ├─ 优先级: P0
│  │  ├─ 预估工时: 6小时
│  │  └─ 负责人: @zhangpeng
│  │
│  ├─ 结构布局 (Structure)
│  │  ├─ 文件清单:
│  │  │  - src/pages/Login/index.tsx
│  │  │  - src/pages/Login/LoginForm.tsx
│  │  │  - src/pages/Login/index.module.css
│  │  │  - src/pages/Login/index.test.tsx
│  │  │
│  │  ├─ 组件树:
│  │  │  LoginPage
│  │  │  ├─ LoginForm
│  │  │  │  ├─ Input (username)
│  │  │  │  ├─ Input (password)
│  │  │  │  └─ Button (submit)
│  │  │  └─ SocialLoginButtons
│  │  │
│  │  └─ 状态管理:
│  │     - Local: form state (react-hook-form)
│  │     - Global: auth state (Zustand)
│  │
│  ├─ 开发约束 (Constraints)
│  │  ├─ 依赖全局文档: @0,1,3,4
│  │  ├─ 技术栈: React 18 + TypeScript + Ant Design
│  │  ├─ 禁止引入: 新的状态管理库、UI库
│  │  └─ 代码量限制: 单文件<200行
│  │
│  ├─ 接口对接 (Integration)
│  │  ├─ 调用API: POST /api/auth/login
│  │  ├─ 请求格式: { username, password, remember }
│  │  ├─ 成功处理: 存储token → 跳转/dashboard
│  │  └─ 失败处理: 显示错误提示
│  │
│  ├─ 验收标准 (Acceptance Criteria)
│  │  ├─ 功能: 
│  │  │  - [ ] 用户名/密码校验正常
│  │  │  - [ ] 登录成功跳转正确
│  │  │  - [ ] 错误提示显示正确
│  │  │  - [ ] Remember me功能正常
│  │  │
│  │  ├─ 性能:
│  │  │  - [ ] 首次渲染<1s
│  │  │  - [ ] 登录请求<2s
│  │  │
│  │  ├─ 兼容性:
│  │  │  - [ ] Chrome/Safari/Firefox最新版
│  │  │  - [ ] 移动端(iPhone/Android)正常
│  │  │
│  │  └─ 安全:
│  │     - [ ] 密码不在Network面板可见
│  │     - [ ] XSS防护通过
│  │
│  └─ 依赖关系 (Dependencies)
│     ├─ 前置任务: BE-001(登录API)必须完成
│     ├─ 阻塞任务: FE-002(仪表盘)等待本任务
│     └─ 并行任务: FE-005(注册页)可同时开发
│
└─ BE-001-auth-api.md
   └─ (类似结构,后端任务)
关键原则:
1. 独立性: 每个任务文档自包含,最小化外部依赖
2. 精确性: 明确到文件级、函数级的结构定义
3. 可测性: 验收标准转化为自动化测试
4. 隔离性: 不同任务使用不同AI会话

---
三、熵减机制:五层入口约束
🚪 Layer 1: 信息入口收束
目标: 减少信息产生量
markdown
传统方式 (高熵):
开发者 → 口头描述需求 → AI理解偏差 → 来回澄清 → 上下文膨胀
         ↓ 产生大量无效信息

熵减方式 (低熵):
PRD → 结构化任务文档 → AI精确执行 → 一次到位
      ↓ 信息密度高,噪音少

具体实践:
┌─────────────────────────────────────┐
│ 信息入口收束矩阵                     │
├─────────────────────────────────────┤
│ 文档类型       信息密度    噪音比    │
│ 口头描述       20%        80%       │
│ 自由文本PRD    50%        50%       │
│ 结构化PRD      80%        20%       │
│ 任务模板       95%        5%   ← 目标 │
└─────────────────────────────────────┘

实施方法:
1. 禁止"口头需求" → AI直接开发
2. 强制使用任务模板 (填空题而非问答题)
3. 模板包含所有必要信息槽位
4. AI拒绝处理不完整的任务文档
模板示例:
markdown
# 任务模板 v2.0

## 必填字段 (AI会检查完整性)
- [ ] 任务ID: _______
- [ ] 功能描述: _______
- [ ] 文件清单: _______
- [ ] 接口依赖: _______
- [ ] 验收标准: _______

## 选填字段
- [ ] UI设计稿: _______
- [ ] 参考实现: _______

## AI自动生成
- 技术栈: (从全局文档读取)
- 代码规范: (从全局文档读取)
- 架构约束: (从全局文档读取)

---
✅ 信息完整性: 100%
🎯 直接可执行: 是

---
🚪 Layer 2: 入口收束 - 单一职责AI会话
目标: 分离式开发,避免上下文污染
markdown
反模式 (高熵):
同一个Claude会话:
1. 开发登录页
2. 开发注册页  
3. 修复登录Bug
4. 重构表单组件
5. 写单元测试
→ Context混乱,熵增严重

正确模式 (低熵):
会话A: 专注登录页 (FE-001)
会话B: 专注注册页 (FE-002)
会话C: 专注Bug修复 (BUG-123)
→ 每个会话单一职责,清晰可控

实施规则:
┌──────────────────────────────────┐
│ 会话生命周期管理                  │
├──────────────────────────────────┤
│ 1会话 = 1任务文档                │
│ 1任务 = 1功能单元                │
│ Context < 60%时可继续             │
│ Context > 60%立即/clear          │
│ 任务完成立即关闭会话              │
└──────────────────────────────────┘

Git Worktrees实现物理隔离:
git worktree add ../task-fe-001 main
cd ../task-fe-001
claude  # 会话A,只开发FE-001

git worktree add ../task-fe-002 main
cd ../task-fe-002
claude  # 会话B,只开发FE-002

→ 两个会话完全隔离,互不干扰

---
🚪 Layer 3: 最短路径规划
目标: 精准切分,最小化改动
markdown
传统开发路径 (高熵):
需求 → 大而全的实现 → 发现问题 → 大规模返工
       (改动面积大,影响不可控)

熵减路径 (低熵):
需求 → 最小可验证单元 → 验证 → 增量扩展
       (小步快跑,每步可控)

MVU原则 (Minimum Viable Unit):
┌────────────────────────────────┐
│ 登录功能拆解                    │
├────────────────────────────────┤
│ MVU-1: 静态UI + 硬编码数据      │  ← 2小时完成,可视化验证
│ MVU-2: 表单交互 + 本地校验      │  ← 1小时,交互验证
│ MVU-3: API对接 + 真实登录       │  ← 2小时,功能验证  
│ MVU-4: 错误处理 + Loading状态  │  ← 1小时,健壮性验证
│ MVU-5: 记住我 + 样式优化        │  ← 1小时,完整性验证
└────────────────────────────────┘

每个MVU:
- 独立可运行
- 独立可验证
- 独立可回滚
- 改动文件<5个
- 改动代码<200行

AI Prompt模式:
> Implement MVU-1 ONLY:
> - Create static UI with hardcoded data
> - DO NOT implement API calls yet
> - DO NOT implement form validation yet
> - Focus: Layout and visual correctness
> 
> Acceptance:
> - [ ] Page renders without errors
> - [ ] All UI elements visible
> - [ ] Matches design mockup

---
🚪 Layer 4: 过程性收束 - 阶段门控制
目标: 每个阶段结束必须产出可审批的制品
markdown
开发流程:
草稿阶段 → 审核门 → 修改阶段 → 审批门 → 成品阶段
   ↓                    ↓                   ↓
  低质量             修正              高质量
  快速产出           反馈              稳定可靠

阶段1: 草稿 + 说明 (Draft + Spec)
──────────────────────────────
输入: 任务文档 FE-001.md
AI动作: Plan Mode分析 + 生成设计方案
输出: 
  - implementation-plan.md (实施计划)
  - file-structure.md (文件结构)
  - api-integration.md (接口对接方案)

人类审核点:
- [ ] 技术选型合理?
- [ ] 文件结构清晰?
- [ ] 接口理解正确?
- [ ] 是否有遗漏?

审核结果: ✅通过 → 进入阶段2
          ❌不通过 → 修改说明,重新Plan

阶段2: 编码实现 (Implementation)
──────────────────────────────
输入: 批准的implementation-plan.md
AI动作: Auto-Accept Mode执行开发
输出:
  - 实际代码文件
  - 单元测试
  - 自测报告

中间检查点 (Checkpoint):
- 每完成1个MVU,自动Checkpoint
- 问题可随时Rewind到上个Checkpoint
- 减少"大改后无法回退"的风险

阶段3: 审批 TODO List (Review)
──────────────────────────────
AI自动生成审批清单:
```markdown
## Code Review Checklist (Auto-Generated)

### 功能完整性
- [x] 登录表单渲染正常
- [x] 表单校验逻辑正确
- [x] API对接成功
- [ ] Remember me功能未实现 ⚠️

### 代码质量
- [x] TypeScript类型完整
- [x] 无ESLint错误
- [ ] 缺少错误边界处理 ⚠️
- [x] 单元测试覆盖率85%

### 安全性
- [x] 密码输入使用type="password"
- [ ] 缺少CSRF Token ⚠️

### 性能
- [x] 首屏渲染<1s
- [x] 无内存泄漏

---
⚠️ 发现3个问题需要修复
```

人类审批:
- 检查⚠️标记的问题
- 决定:
  - ✅ 通过 → 合并代码
  - 🔄 返工 → 回到阶段2
  - ❌ 拒绝 → 回到阶段1重新设计

阶段4: 末端文档生成 (Documentation)
──────────────────────────────
AI自动生成:
- CHANGELOG.md更新
- 本任务的实施总结
- 遇到的问题和解决方案
- 经验教训(更新experience-library.md)

输出示例:
```markdown
# FE-001 实施总结

## 完成情况
- 开发时间: 6小时 (预估6小时)
- 代码量: 450行 (3个组件 + 测试)
- 测试覆盖率: 85%

## 技术决策
1. 表单管理: 使用react-hook-form
   理由: 轻量,性能好,符合项目规范
   
2. 状态管理: 登录状态用Zustand
   理由: 需要全局共享

## 遇到的问题
1. Ant Design Form与react-hook-form冲突
   解决: 使用Controller包装
   用时: 1小时
   
2. Token存储位置选择
   决策: localStorage(考虑到Remember me需求)
   讨论: @全局文档-5-security.md

## 经验教训
✅ 应该做: 先完成UI,再对接API(符合MVU原则)
❌ 不该做: 试图一次性完成所有功能

## 更新文档
- 更新: experience-library.md (新增1条教训)
- 更新: ROADMAP.md (标记FE-001为已完成)
```

---
🚪 Layer 5: AI全流程协作
目标: AI不仅开发,还要计划、审批、测试
markdown
多Agent协作模式:

┌─────────────────────────────────────────┐
│         Orchestrator (协调者)            │
│  职责: 读取任务文档,分配给专业Agent      │
└──────────────┬──────────────────────────┘
               │
       ┌───────┼───────┬─────────┬─────────┐
       │       │       │         │         │
    ┌──▼──┐ ┌─▼──┐ ┌──▼───┐ ┌───▼──┐ ┌───▼──┐
    │Plan │ │Dev │ │Review│ │ Test │ │ Doc  │
    │Agent│ │Agent│ │Agent │ │Agent │ │Agent │
    └─────┘ └────┘ └──────┘ └──────┘ └──────┘
工作流实现:
markdown
# .claude/workflows/full-cycle.md

## 任务: 实现FE-001登录页面

### Phase 1: AI Planning
Agent: Plan Specialist (claude-opus-4)
Input: @tasks/FE-001-login-page.md + @全局文档
Action: 
  1. Analyze requirements
  2. Design architecture
  3. Identify risks
  4. Create implementation plan
Output: /tmp/fe-001-plan.md
Approval: Human reviews plan

### Phase 2: AI Development  
Agent: Dev Specialist (claude-sonnet-4)
Input: @/tmp/fe-001-plan.md
Action:
  1. Generate code following plan
  2. Write unit tests
  3. Run linter
  4. Self-test
Output: Code + Tests + Self-test Report
Checkpoint: Auto-save after each MVU

### Phase 3: AI Code Review
Agent: Review Specialist (claude-sonnet-4)
Input: Git diff + Code
Action:
  1. Check against code standards
  2. Identify security issues
  3. Check performance
  4. Generate review report
Output: review-report.md with checklist
Approval: Human reviews report

### Phase 4: AI Testing
Agent: Test Specialist (claude-sonnet-4)
Input: Implementation + Test cases
Action:
  1. Run unit tests
  2. Run integration tests  
  3. Check coverage
  4. Generate test report
Output: test-report.md
Gate: Coverage must > 80%

### Phase 5: AI Documentation
Agent: Doc Specialist (claude-haiku)
Input: Code + Comments + Commits
Action:
  1. Extract API documentation
  2. Update CHANGELOG
  3. Generate implementation summary
  4. Update experience library
Output: Updated docs in repo
Slash Command封装:
bash
# .claude/commands/full-cycle-dev.md

Execute the full development cycle for task $ARGUMENTS.

Workflow:
1. /plan $ARGUMENTS       # Plan Agent
2. Wait for human approval
3. /develop $ARGUMENTS    # Dev Agent  
4. /review $ARGUMENTS     # Review Agent
5. /test $ARGUMENTS       # Test Agent
6. /document $ARGUMENTS   # Doc Agent
7. Report completion

Usage:
> /full-cycle-dev FE-001

AI will orchestrate all 5 agents automatically.
Human intervention only at approval gates.

---